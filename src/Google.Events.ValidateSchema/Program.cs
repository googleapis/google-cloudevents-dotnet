// Copyright 2020, Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Google.Protobuf;
using Google.Protobuf.Reflection;
using Newtonsoft.Json.Linq;
using System;
using System.IO;
using System.Reflection;

namespace Google.Events.ValidateSchema
{
    /// <summary>
    /// Finds all test data in a google-cloudevents repository, the location of which
    /// is specified on the command line, and validates that each file can be parsed
    /// (without ignoring any fields other than some expected ones) by the C# generated
    /// from that repo. See the validate-schema.sh file in the repository root for
    /// more details.
    /// 
    /// Note that this is a console app instead of a unit test app as it simplifies various
    /// aspects, including allowing "dotnet test" to continue to work on the whole solution.
    /// The exit code indicates success or failure, however.
    /// </summary>
    internal class Program
    {
        private static readonly JsonParser LooseParser = new JsonParser(JsonParser.Settings.Default.WithIgnoreUnknownFields(true));
        private static readonly JsonParser StrictParser = JsonParser.Default;

        /// <summary>
        /// Entry point, accepting the location of the test data. This iterates over all the JSON files
        /// recursively, calling <see cref="ValidateSchemaData(string, string)"/> on each one.
        /// </summary>
        private static int Main(string[] args)
        {
            if (args.Length != 1)
            {
                Console.WriteLine("Expected a single command line argument: the location of the test data");
                return 1;
            }
            string testRoot = args[0];

            var files = Directory.GetFiles(testRoot, "*.json", SearchOption.AllDirectories);
            int failures = 0;
            foreach (var file in files)
            {
                if (!ValidateSchemaData(testRoot, file))
                {
                    failures++;
                }
            }

            Console.WriteLine($"Tests: {files.Length}");
            Console.WriteLine($"Passed: {files.Length - failures}");
            Console.WriteLine($"Failed: {failures}");
            return failures == 0 ? 0 : 1;
        }

        /// <summary>
        /// Validates that given test file can be parsed by the generated code.
        /// </summary>
        /// <param name="testRoot">Root directory of the test data</param>
        /// <param name="file">Full name of the test file</param>
        /// <returns>true if the test passes; false if it fails</returns>
        private static bool ValidateSchemaData(string testRoot, string file)
        {
            string relativePath = Path.GetRelativePath(testRoot, file).Replace('\\', '/');
            Console.Write($"Testing {relativePath}: ");
            string json = File.ReadAllText(file);
            try
            {
                var descriptor = GetProtobufDescriptor(relativePath);
                // Check we can parse the original JSON in a "loose" way (ignoring unknown fields) - this is how the
                // converter in Google.Events.Protobuf works.
                LooseParser.Parse(json, descriptor);

                // Remove "expected unknown fields" and parse in a stricter way, to make sure there aren't
                // any *unexpected* unknown fields.
                json = MaybeModifyJson(descriptor.File.Package, descriptor.Name, json);
                StrictParser.Parse(json, descriptor);
                Console.WriteLine("Pass");
                return true;
            }
            catch (Exception e)
            {
                Console.WriteLine("Fail");
                Console.WriteLine(e);
                return false;
            }
        }

        /// <summary>
        /// Finds the protobuf descriptor for the .NET type in the current assembly (generated by validate-schema.sh)
        /// that corresponds to the given test file. Effectively, we strip off the extension and any optional description,
        /// turn slashes into dots, handle the convention of the C# namespace starting "Google.Events.Protobuf",
        /// then perform a case-insentive match.
        /// 
        /// For example, google/events/cloud/pubsub/v1/MessagePublishedData matches
        /// Google.Events.Protobuf.Cloud.PubSub.V1.MessagePublishedData.
        /// </summary>
        /// <param name="relativeFile">The name of the test file, relative to the test root.</param>
        private static MessageDescriptor GetProtobufDescriptor(string relativeFile)
        {
            string directory = Path.GetDirectoryName(relativeFile);
            string protoPackage = directory.Replace('\\', '/').Replace('/', '.');
            string expectedNamespace = protoPackage.Replace("google.events", "google.events.protobuf");
            string messageName = Path.GetFileName(relativeFile).Split('.', '-')[0];
            var messageType = typeof(Program).Assembly.GetType(
                $"{expectedNamespace}.{messageName}",
                throwOnError: true,
                ignoreCase: true);
            if (messageType is null)
            {
                throw new InvalidOperationException($"Unable to determine expected event type from relative file name '{relativeFile}'");
            }
            return (MessageDescriptor) messageType
                .GetProperty("Descriptor", BindingFlags.Public | BindingFlags.Static)
                .GetValue(null);
        }

        /// <summary>
        /// Perform any modifications we need to account for proto JSON representation oddities. (Note that
        /// these are *not* an issue 
        /// 
        /// Currently this consists of:
        /// - Removing @type from google.events.cloud.audit.v1.LogEntryData.protoPayload
        /// - Removing @type from google.events.cloud.pubsub.v1.MessagePublishedData.message
        ///   (These are the result of an "Any" being serialized.)
        /// </summary>
        private static string MaybeModifyJson(string protoPackage, string messageName, string json)
        {
            if (protoPackage == "google.events.cloud.audit.v1" && messageName == "LogEntryData")
            {
                var rootObject = JObject.Parse(json);
                var protoPayload = (JObject) rootObject["protoPayload"];
                protoPayload?.Remove("@type");
                return rootObject.ToString();
            }

            if (protoPackage == "google.events.cloud.pubsub.v1" && messageName == "MessagePublishedData")
            {
                var rootObject = JObject.Parse(json);
                var protoPayload = (JObject) rootObject["message"];
                protoPayload?.Remove("@type");
                return rootObject.ToString();
            }
            return json;
        }
    }
}
